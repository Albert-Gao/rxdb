{"version":3,"sources":["../../../src/plugins/attachments.ts"],"names":["map","blobBufferUtil","flatClone","newRxError","hashAttachmentData","writeSingle","runAsyncPluginHooks","ensureSchemaSupportsAttachments","doc","schemaJson","collection","schema","jsonSchema","attachments","link","postMigrateDocument","_action","preMigrateDocument","data","docData","_attachments","newAttachments","Promise","all","Object","keys","attachmentId","attachment","docPrimary","oldCollection","primaryPath","storageInstance","getAttachmentData","rawAttachmentData","hookInput","database","type","plainData","digest","length","putAttachment","attachmentData","skipIfSame","dataSize","size","storageStatics","storage","statics","toBase64String","dataString","hookAttachmentData","id","then","hash","hashKey","newDigest","_atomicQueue","_data","currentMeta","getAttachment","docWriteData","writeRow","previous","document","writeResult","fromStorageInstanceResult","newData","_rev","_dataSync$","next","_assignMethodsToAttachment","entries","forEach","funName","fun","defineProperty","get","bind","RxAttachment","remove","getData","primary","plainDataBase64","createBlobBufferFromBase64","getStringData","toString","rxDocument","getValue","allAttachments","RxDBAttachmentsPlugin","name","rxdb","prototypes","RxDocument","proto","allAttachments$","pipe","attachmentsData","overwritable","hooks","after"],"mappings":"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","sourcesContent":["import {\n    map\n} from 'rxjs/operators';\n\nimport {\n    blobBufferUtil,\n    flatClone\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData\n} from '../types';\nimport { hashAttachmentData, writeSingle } from '../rx-storage-helper';\nimport { runAsyncPluginHooks } from '../hooks';\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    async remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatClone(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: flatClone(this.doc._data),\n                        document: docWriteData\n                    }\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        const hookInput = {\n            database: this.doc.collection.database,\n            schema: this.doc.collection.schema.jsonSchema,\n            type: this.type,\n            plainData: plainDataBase64\n        };\n        await runAsyncPluginHooks('postReadAttachment', hookInput);\n        const ret = await blobBufferUtil.createBlobBufferFromBase64(\n            hookInput.plainData,\n            this.type as any\n        );\n        return ret;\n    }\n\n    async getStringData(): Promise<string> {\n        const data = await this.getData();\n        const asString = await blobBufferUtil.toString(data);\n        return asString;\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    attachmentData: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n\n    const dataSize = blobBufferUtil.size(attachmentData.data);\n    const storageStatics = this.collection.database.storage.statics;\n    const dataString = await blobBufferUtil.toBase64String(attachmentData.data);\n\n    const hookAttachmentData = {\n        id: attachmentData.id,\n        type: attachmentData.type,\n        data: dataString\n    };\n    await runAsyncPluginHooks('preWriteAttachment', {\n        database: this.collection.database,\n        schema: this.collection.schema.jsonSchema,\n        attachmentData: hookAttachmentData\n    });\n\n    const {\n        id, data, type\n    } = hookAttachmentData;\n\n    const newDigest = await hashAttachmentData(\n        dataString,\n        storageStatics\n    ).then(hash => storageStatics.hashKey + '-' + hash);\n\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                if (currentMeta.type === type && currentMeta.digest === newDigest) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatClone(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n\n            docWriteData._attachments[id] = {\n                digest: newDigest,\n                length: dataSize,\n                type,\n                data\n            };\n\n            const writeRow = {\n                previous: flatClone(this._data),\n                document: flatClone(docWriteData)\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n\n                let rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n\n                const hookInput = {\n                    database: data.oldCollection.database,\n                    schema: data.oldCollection.schema.jsonSchema,\n                    type: attachment.type,\n                    plainData: rawAttachmentData\n                };\n                await runAsyncPluginHooks('postReadAttachment', hookInput);\n                rawAttachmentData = hookInput.plainData;\n\n                newAttachments[attachmentId] = {\n                    digest: attachment.digest,\n                    length: attachment.length,\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport async function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachemnts data buffers directly in the document.\n     */\n    return;\n}\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb: true,\n    prototypes: {\n        RxDocument: (proto: any) => {\n            proto.putAttachment = putAttachment;\n            proto.getAttachment = getAttachment;\n            proto.allAttachments = allAttachments;\n            Object.defineProperty(proto, 'allAttachments$', {\n                get: function allAttachments$() {\n                    return this._dataSync$\n                        .pipe(\n                            map((data: any) => {\n                                if (!data['_attachments']) {\n                                    return {};\n                                }\n                                return data['_attachments'];\n                            }),\n                            map((attachmentsData: any) => Object.entries(\n                                attachmentsData\n                            )),\n                            map(entries => {\n                                return (entries as any)\n                                    .map(([id, attachmentData]: any) => {\n                                        return fromStorageInstanceResult(\n                                            id,\n                                            attachmentData,\n                                            this\n                                        );\n                                    });\n                            })\n                        );\n                }\n            });\n        }\n    },\n    overwritable: {},\n    hooks: {\n        preMigrateDocument: {\n            after: preMigrateDocument\n        },\n        postMigrateDocument: {\n            after: postMigrateDocument\n        }\n    }\n};\n"],"file":"attachments.js"}