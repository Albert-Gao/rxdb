{"version":3,"sources":["../../src/rx-collection.ts"],"names":["filter","startWith","mergeMap","shareReplay","ucfirst","flatClone","promiseSeries","pluginMissing","ensureNotFalsy","getFromMapOrThrow","clone","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_VOID","RXJS_SHARE_REPLAY_DEFAULTS","getDefaultRxDocumentMeta","getDefaultRevision","nextTick","fillObjectDataBeforeInsert","createRxCollectionStorageInstance","createRxQuery","_getDefaultQuery","newRxError","newRxTypeError","DocCache","createQueryCache","defaultCacheReplacementPolicy","createChangeEventBuffer","runAsyncPluginHooks","runPluginHooks","createWithConstructor","createRxDocumentWithConstructor","isRxDocument","createRxDocument","getRxDocumentConstructor","getWrappedStorageInstance","storageChangeEventToRxChangeEvent","throwIfIsStorageWriteError","HOOKS_WHEN","HOOKS_KEYS","hooksApplied","RxCollectionBase","database","name","schema","internalStorageInstance","instanceCreationOptions","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","statics","storageInstance","timeouts","Set","destroyed","_atomicUpsertQueues","Map","synced","hooks","_subs","_docCache","_queryCache","$","_changeEventBuffer","_applyHookFunctions","asRxCollection","prepare","jsonSchema","eventBulks$","pipe","changeEventBulk","collectionName","events","storageToken","databaseStorageToken","subDocs","changeStream","subscribe","eventBulk","id","internal","map","ev","databaseToken","token","$emit","push","cE","isLocal","doc","get","documentId","_handleChangeEvent","migrationNeeded","getDataMigrator","migrate","batchSize","migratePromise","insert","json","tempDoc","_isTemporary","data","toJSON","useJson","bulkInsert","writeResult","isError","error","primaryPath","insertResult","success","_dataSync$","next","_data","docsData","length","useDocs","docData","useDocData","Promise","all","_runHooks","then","validate","docs","docsMap","insertRows","set","row","document","Object","assign","_attachments","_meta","_rev","_deleted","bulkWrite","results","successEntries","entries","rxDocuments","key","writtenDocData","primary","values","bulkRemove","ids","findByIds","rxDocumentMap","Array","from","forEach","rxDocument","removeDocs","writeDoc","previous","successIds","keys","bulkUpsert","insertData","useJsonByDocId","ret","slice","writeData","docDataInDb","documentInDb","atomicUpdate","updatedDocs","concat","upsert","result","atomicUpsert","queue","_atomicUpsertEnsureRxDocumentExists","wasInserted","inserted","_atomicUpsertUpdate","find","queryObj","query","findOne","selector","limit","isArray","mustBeQueried","findDocumentsById","findByIds$","currentValue","lastChangeEvent","initialPromise","counter","firstEmitDone","changeEvent","includes","missedChangeEvents","getFrom","newResult","resultHasChanged","rxChangeEvent","docId","op","operation","documentData","has","x","exportJSON","importJSON","_exportedJSON","syncCouchDB","_syncOptions","syncGraphQL","_options","addHook","when","fun","parallel","boundFun","bind","runName","series","getHooks","e","instance","tasks","hook","_runHooksSync","newDocument","filledDocData","fillObjectWithDefaults","promiseWait","time","res","timeout","setTimeout","add","destroy","_onDestroyCall","clearTimeout","sub","unsubscribe","requestIdlePromise","close","collections","remove","removeCollection","_onDestroy","collection","colProto","getPrototypeOf","fnName","_innerDoc","rxCollection","docFromCache","resolve","exec","newDoc","createRxCollection","autoMigrate","localDocuments","storageInstanceCreationParams","databaseName","multiInstance","funName","defineProperty","version","creator","err","reject","isRxCollection","obj"],"mappings":"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","sourcesContent":["import {\n    filter,\n    startWith,\n    mergeMap,\n    shareReplay\n} from 'rxjs/operators';\n\nimport {\n    ucfirst,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    clone,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    getDefaultRxDocumentMeta,\n    getDefaultRevision,\n    nextTick\n} from './util';\nimport {\n    fillObjectDataBeforeInsert,\n    createRxCollectionStorageInstance\n} from './rx-collection-helper';\nimport {\n    createRxQuery,\n    _getDefaultQuery\n} from './rx-query';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error';\nimport type {\n    DataMigrator\n} from './plugins/migration';\nimport {\n    DocCache\n} from './doc-cache';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks';\n\nimport {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCouchDBReplicationState,\n    MigrationState,\n    SyncOptions,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    SyncOptionsGraphQL,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageBulkWriteError,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxStorageInstanceCreationParams,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase,\n    RxChangeEventBulk,\n    RxLocalDocumentData,\n    RxDocumentBase\n} from './types';\nimport type {\n    RxGraphQLReplicationState\n} from './plugins/replication-graphql';\n\nimport {\n    RxSchema\n} from './rx-schema';\nimport {\n    createWithConstructor as createRxDocumentWithConstructor,\n    isRxDocument\n} from './rx-document';\n\nimport {\n    createRxDocument,\n    getRxDocumentConstructor\n} from './rx-document-prototype-merge';\nimport {\n    getWrappedStorageInstance,\n    storageChangeEventToRxChangeEvent,\n    throwIfIsStorageWriteError\n} from './rx-storage-helper';\n\nconst HOOKS_WHEN = ['pre', 'post'];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nlet hooksApplied = false;\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any }\n    > {\n\n\n    /**\n     * Stores all 'normal' documents\n     */\n    public storageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\n\n    constructor(\n        public database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: KeyFunctionMap = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {}\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n    }\n\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    get onDestroy() {\n        if (!this._onDestroy) {\n            this._onDestroy = new Promise(res => this._onDestroyCall = res);\n        }\n        return this._onDestroy;\n    }\n\n    public destroyed = false;\n    public _atomicUpsertQueues: Map<string, Promise<any>> = new Map();\n    // defaults\n    public synced: boolean = false;\n    public hooks: any = {};\n    public _subs: Subscription[] = [];\n\n    public _docCache: DocCache<\n        RxDocument<RxDocumentType, OrmMethods>\n    > = new DocCache();\n\n    public _queryCache: QueryCache = createQueryCache();\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer = {} as ChangeEventBuffer;\n\n    /**\n     * returns a promise that is resolved when the collection gets destroyed\n     */\n    private _onDestroy?: Promise<void>;\n\n    private _onDestroyCall?: () => void;\n    public async prepare(): Promise<void> {\n        this.storageInstance = getWrappedStorageInstance(\n            this.database,\n            this.internalStorageInstance,\n            this.schema.jsonSchema\n        );\n\n        this.$ = this.database.eventBulks$.pipe(\n            filter(changeEventBulk => changeEventBulk.collectionName === this.name),\n            mergeMap(changeEventBulk => changeEventBulk.events),\n        );\n        this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n\n\n        /**\n         * Instead of resolving the EventBulk array here and spit it into\n         * single events, we should fully work with event bulks internally\n         * to save performance.\n         */\n        const databaseStorageToken = await this.database.storageToken;\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\n                id: eventBulk.id,\n                internal: false,\n                collectionName: this.name,\n                storageToken: databaseStorageToken,\n                events: eventBulk.events.map(ev => storageChangeEventToRxChangeEvent(\n                    false,\n                    ev,\n                    this as any\n                )),\n                databaseToken: this.database.token\n            };\n            this.database.$emit(changeEventBulk);\n        });\n        this._subs.push(subDocs);\n\n        /**\n         * When a write happens to the collection\n         * we find the changed document in the docCache\n         * and tell it that it has to change its data.\n         */\n        this._subs.push(\n            this.$\n                .pipe(\n                    filter((cE: RxChangeEvent<RxDocumentType>) => !cE.isLocal)\n                )\n                .subscribe(cE => {\n                    // when data changes, send it to RxDocument in docCache\n                    const doc = this._docCache.get(cE.documentId);\n                    if (doc) {\n                        doc._handleChangeEvent(cE);\n                    }\n                })\n        );\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n\n    // overwritte by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration');\n    }\n    getDataMigrator(): DataMigrator {\n        throw pluginMissing('migration');\n    }\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        return this.getDataMigrator().migrate(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getDataMigrator().migratePromise(batchSize);\n    }\n\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        // inserting a temporary-document\n        let tempDoc: RxDocument | null = null;\n        if (isRxDocument(json)) {\n            tempDoc = json as RxDocument;\n            if (!tempDoc._isTemporary) {\n                throw newRxError('COL1', {\n                    data: json\n                });\n            }\n            json = tempDoc.toJSON() as any;\n        }\n\n        const useJson: RxDocumentWriteData<RxDocumentType> = fillObjectDataBeforeInsert(this.schema, json);\n        const writeResult = await this.bulkInsert([useJson]);\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this as any, useJson[this.schema.primaryPath] as any, json, isError);\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\n\n        if (tempDoc) {\n            tempDoc._dataSync$.next(insertResult._data);\n            return tempDoc as any;\n        } else {\n            return insertResult;\n        }\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const useDocs: RxDocumentType[] = docsData.map(docData => {\n            const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n            return useDocData;\n        });\n        const docs = await Promise.all(\n            useDocs.map(doc => {\n                return this._runHooks('pre', 'insert', doc).then(() => {\n                    this.schema.validate(doc);\n                    return doc;\n                });\n            })\n        );\n\n        const docsMap: Map<string, RxDocumentType> = new Map();\n        const insertRows: BulkWriteRow<RxDocumentType>[] = docs.map(doc => {\n            docsMap.set((doc as any)[this.schema.primaryPath] as any, doc);\n            const row: BulkWriteRow<RxDocumentType> = {\n                document: Object.assign(doc, {\n                    _attachments: {},\n                    _meta: getDefaultRxDocumentMeta(),\n                    _rev: getDefaultRevision(),\n                    _deleted: false\n                })\n            };\n            return row;\n        });\n\n        const results = await this.storageInstance.bulkWrite(insertRows);\n\n        // create documents\n        const successEntries: [string, RxDocumentData<RxDocumentType>][] = Object.entries(results.success);\n        const rxDocuments: any[] = successEntries\n            .map(([key, writtenDocData]) => {\n                const docData: RxDocumentData<RxDocumentType> = getFromMapOrThrow(docsMap, key) as any;\n                docData._rev = writtenDocData._rev;\n\n                const doc = createRxDocument(this as any, docData);\n                return doc;\n            });\n\n\n        await Promise.all(\n            rxDocuments.map(doc => {\n                return this._runHooks(\n                    'post', 'insert',\n                    docsMap.get(doc.primary),\n                    doc\n                );\n            })\n        );\n\n        return {\n            success: rxDocuments,\n            error: Object.values(results.error)\n        };\n    }\n\n    async bulkRemove(\n        ids: string[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (ids.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const rxDocumentMap = await this.findByIds(ids);\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = clone(rxDocument.toJSON(true)) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n\n\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        const results = await this.storageInstance.bulkWrite(removeDocs);\n\n        const successIds: string[] = Object.keys(results.success);\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n        const rxDocuments: any[] = successIds.map(id => {\n            return rxDocumentMap.get(id);\n        });\n\n        return {\n            success: rxDocuments,\n            error: Object.values(results.error)\n        };\n    }\n\n    /**\n     * same as bulkInsert but overwrites existing document with same primary\n     */\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<RxDocument<RxDocumentType, OrmMethods>[]> {\n        const insertData: RxDocumentType[] = [];\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\n        docsData.forEach(docData => {\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\n            const primary: string = useJson[this.schema.primaryPath] as any;\n            if (!primary) {\n                throw newRxError('COL3', {\n                    primaryPath: this.schema.primaryPath as string,\n                    data: useJson,\n                    schema: this.schema.jsonSchema\n                });\n            }\n            useJsonByDocId.set(primary, useJson);\n            insertData.push(useJson);\n        });\n\n        const insertResult = await this.bulkInsert(insertData);\n        let ret = insertResult.success.slice(0);\n        const updatedDocs = await Promise.all(\n            insertResult.error.map(error => {\n                const id = error.documentId;\n                const writeData = getFromMapOrThrow(useJsonByDocId, id);\n                const docDataInDb = error.documentInDb;\n                const doc = createRxDocument(this.asRxCollection, docDataInDb);\n                return doc.atomicUpdate(() => writeData);\n            })\n        );\n        ret = ret.concat(updatedDocs);\n        return ret;\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        return this.bulkUpsert([json]).then(result => result[0]);\n    }\n\n    /**\n     * upserts to a RxDocument, uses atomicUpdate if document already exists\n     */\n    atomicUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\n        const primary: string = useJson[this.schema.primaryPath] as any;\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it wont try 2 parallel runs\n        let queue = this._atomicUpsertQueues.get(primary);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue\n            .then(() => _atomicUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted: any) => {\n                if (!wasInserted.inserted) {\n                    return _atomicUpsertUpdate(wasInserted.doc, useJson)\n                        .then(() => wasInserted.doc);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._atomicUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[]\n    > {\n        if (typeof queryObj === 'string') {\n            throw newRxError('COL5', {\n                queryObj\n            });\n        }\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this as any);\n        return query as any;\n    }\n\n    findOne(queryObj?: MangoQueryNoLimit<RxDocumentType> | string): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>\n        | null\n    > {\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                },\n                limit: 1\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n            // cannot have limit on findOne queries because it will be overwritte\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            (queryObj as any).limit = 1;\n            query = createRxQuery('findOne', queryObj, this as any);\n        }\n\n        if (\n            typeof queryObj === 'number' ||\n            Array.isArray(queryObj)\n        ) {\n            throw newRxTypeError('COL6', {\n                queryObj\n            });\n        }\n\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    async findByIds(\n        ids: string[]\n    ): Promise<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n\n        const ret = new Map();\n        const mustBeQueried: string[] = [];\n\n        // first try to fill from docCache\n        ids.forEach(id => {\n            const doc = this._docCache.get(id);\n            if (doc) {\n                ret.set(id, doc);\n            } else {\n                mustBeQueried.push(id);\n            }\n        });\n\n        // find everything which was not in docCache\n        if (mustBeQueried.length > 0) {\n            const docs = await this.storageInstance.findDocumentsById(mustBeQueried, false);\n            Object.values(docs).forEach(docData => {\n                const doc = createRxDocument<RxDocumentType, OrmMethods>(this as any, docData);\n                ret.set(doc.primary, doc);\n            });\n        }\n        return ret;\n    }\n\n    /**\n     * like this.findByIds but returns an observable\n     * that always emits the current state\n     */\n    findByIds$(\n        ids: string[]\n    ): Observable<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n        let currentValue: Map<string, RxDocument<RxDocumentType, OrmMethods>> | null = null;\n        let lastChangeEvent: number = -1;\n\n        /**\n         * Ensure we do not process events in parallel\n         */\n        let queue: Promise<any> = PROMISE_RESOLVE_VOID;\n\n        const initialPromise = this.findByIds(ids).then(docsMap => {\n            lastChangeEvent = this._changeEventBuffer.counter;\n            currentValue = docsMap;\n        });\n        let firstEmitDone = false;\n\n        return this.$.pipe(\n            startWith(null),\n            /**\n             * Optimization shortcut.\n             * Do not proceed if the emited RxChangeEvent\n             * is not relevant for the query.\n             */\n            filter(changeEvent => {\n                if (\n                    // first emit has no event\n                    changeEvent &&\n                    (\n                        // local documents are not relevant for the query\n                        changeEvent.isLocal ||\n                        // document of the change is not in the ids list.\n                        !ids.includes(changeEvent.documentId)\n                    )\n                ) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }),\n            mergeMap(() => initialPromise),\n            /**\n             * Because shareReplay with refCount: true\n             * will often subscribe/unsusbscribe\n             * we always ensure that we handled all missed events\n             * since the last subscription.\n             */\n            mergeMap(() => {\n                queue = queue.then(async () => {\n                    /**\n                     * We first have to clone the Map\n                     * to ensure we do not create side effects by mutating\n                     * a Map that has already been returned before.\n                     */\n                    currentValue = new Map(ensureNotFalsy(currentValue));\n                    const missedChangeEvents = this._changeEventBuffer.getFrom(lastChangeEvent + 1);\n                    lastChangeEvent = this._changeEventBuffer.counter;\n                    if (missedChangeEvents === null) {\n                        /**\n                         * changeEventBuffer is of bounds -> we must re-execute over the database\n                         * because we cannot calculate the new results just from the events.\n                         */\n                        const newResult = await this.findByIds(ids);\n                        lastChangeEvent = this._changeEventBuffer.counter;\n                        return newResult;\n                    } else {\n                        let resultHasChanged = false;\n                        missedChangeEvents\n                            .forEach(rxChangeEvent => {\n                                const docId = rxChangeEvent.documentId;\n                                if (!ids.includes(docId)) {\n                                    // document is not relevant for the result set\n                                    return;\n                                }\n                                const op = rxChangeEvent.operation;\n                                if (op === 'INSERT' || op === 'UPDATE') {\n                                    resultHasChanged = true;\n                                    const rxDocument = createRxDocument(\n                                        this.asRxCollection,\n                                        rxChangeEvent.documentData\n                                    );\n                                    ensureNotFalsy(currentValue).set(docId, rxDocument);\n                                } else {\n                                    if (ensureNotFalsy(currentValue).has(docId)) {\n                                        resultHasChanged = true;\n                                        ensureNotFalsy(currentValue).delete(docId);\n                                    }\n                                }\n                            });\n\n                        // nothing happened that affects the result -> do not emit\n                        if (!resultHasChanged && firstEmitDone) {\n                            return false as any;\n                        }\n                    }\n                    firstEmitDone = true;\n                    return currentValue;\n                });\n                return queue;\n            }),\n            filter(x => !!x),\n            shareReplay(RXJS_SHARE_REPLAY_DEFAULTS)\n        );\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     * @param _decrypted\n     * When true, all encrypted values will be decrypted.\n     * When false or omitted and an interface or type is loaded in this collection,\n     * all base properties of the type are typed as `any` since data could be encrypted.\n     */\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * sync with a CouchDB endpoint\n     */\n    syncCouchDB(_syncOptions: SyncOptions): RxCouchDBReplicationState {\n        throw pluginMissing('replication');\n    }\n\n    /**\n     * sync with a GraphQL endpoint\n     */\n    syncGraphQL(_options: SyncOptionsGraphQL<RxDocumentType>): RxGraphQLReplicationState<RxDocumentType> {\n        throw pluginMissing('replication-graphql');\n    }\n\n    /**\n     * HOOKS\n     */\n    addHook(when: string, key: string, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n\n    getHooks(when: string, key: string) {\n        try {\n            return this.hooks[key][when];\n        } catch (e) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n    }\n\n    _runHooks(when: string, key: string, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: string, key: string, data: any, instance: any) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * creates a temporaryDocument which can be saved later\n     */\n    newDocument(docData: Partial<RxDocumentType> = {}): RxDocument<RxDocumentType, OrmMethods> {\n        const filledDocData: RxDocumentData<RxDocumentType> = this.schema.fillObjectWithDefaults(docData);\n        const doc: any = createRxDocumentWithConstructor(\n            getRxDocumentConstructor(this as any),\n            this as any,\n            filledDocData\n        );\n        doc._isTemporary = true;\n\n        this._runHooksSync('post', 'create', docData, doc);\n        return doc as any;\n    }\n\n    /**\n     * Returns a promise that resolves after the given time.\n     * Ensures that is properly cleans up when the collection is destroyed\n     * so that no running timeouts prevent the exit of the JavaScript process.\n     */\n    promiseWait(time: number): Promise<void> {\n        const ret = new Promise<void>(res => {\n            const timeout = setTimeout(() => {\n                this.timeouts.delete(timeout);\n                res();\n            }, time);\n            this.timeouts.add(timeout);\n        });\n        return ret;\n    }\n\n    async destroy(): Promise<boolean> {\n        if (this.destroyed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        /**\n         * Settings destroyed = true\n         * must be the first thing to do,\n         * so for example the replication can directly stop\n         * instead of sending requests to a closed storage.\n         */\n        this.destroyed = true;\n\n        if (this._onDestroyCall) {\n            this._onDestroyCall();\n        }\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n        this._subs.forEach(sub => sub.unsubscribe());\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.destroy();\n        }\n        /**\n         * First wait until the whole database is idle.\n         * This ensures that the storage does not get closed\n         * while some operation is running.\n         * It is important that we do not intercept a running call\n         * because it might lead to undefined behavior like when a doc is written\n         * but the change is not added to the changes collection.\n         */\n        return this.database.requestIdlePromise()\n            .then(() => this.storageInstance.close())\n            .then(() => {\n                delete this.database.collections[this.name];\n                return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    remove(): Promise<any> {\n        return this.database.removeCollection(this.name);\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _atomicUpsertUpdate<RxDocType>(\n    doc: RxDocumentBase<RxDocType>,\n    json: RxDocumentData<RxDocType>\n): Promise<RxDocumentBase<RxDocType>> {\n    return doc.atomicUpdate((_innerDoc: RxDocumentData<RxDocType>) => {\n        return json;\n    })\n        .then(() => nextTick())\n        .then(() => {\n            return doc;\n        });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _atomicUpsertEnsureRxDocumentExists(\n    rxCollection: RxCollection,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument,\n        inserted: boolean\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docFromCache = rxCollection._docCache.get(primary);\n    if (docFromCache) {\n        return Promise.resolve({\n            doc: docFromCache,\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        localDocuments = false,\n        cacheReplacementPolicy = defaultCacheReplacementPolicy\n    }: any\n): Promise<RxCollection> {\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions,\n        multiInstance: database.multiInstance\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    return createRxCollectionStorageInstance(\n        database,\n        storageInstanceCreationParams\n    ).then(storageInstance => {\n        const collection = new RxCollectionBase(\n            database,\n            name,\n            schema,\n            storageInstance,\n            instanceCreationOptions,\n            migrationStrategies,\n            methods,\n            attachments,\n            options,\n            cacheReplacementPolicy,\n            statics\n        );\n\n        return collection\n            .prepare()\n            .then(() => {\n                // ORM add statics\n                Object\n                    .entries(statics)\n                    .forEach(([funName, fun]) => {\n                        Object.defineProperty(collection, funName, {\n                            get: () => (fun as any).bind(collection)\n                        });\n                    });\n\n                let ret = PROMISE_RESOLVE_VOID;\n                if (autoMigrate && collection.schema.version !== 0) {\n                    ret = collection.migratePromise();\n                }\n                return ret;\n            })\n            .then(() => {\n                runPluginHooks('createRxCollection', {\n                    collection,\n                    creator: {\n                        name,\n                        schema,\n                        storageInstance,\n                        instanceCreationOptions,\n                        migrationStrategies,\n                        methods,\n                        attachments,\n                        options,\n                        cacheReplacementPolicy,\n                        localDocuments,\n                        statics\n                    }\n                });\n                return collection as any;\n            })\n            /**\n             * If the collection creation fails,\n             * we yet have to close the storage instances.\n             */\n            .catch(err => {\n                return storageInstance.close()\n                    .then(() => Promise.reject(err));\n            });\n    });\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n"],"file":"rx-collection.js"}