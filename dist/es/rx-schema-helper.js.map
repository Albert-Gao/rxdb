{"version":3,"sources":["../../src/rx-schema-helper.ts"],"names":["objectPath","newRxError","clone","flatClone","isMaybeReadonlyArray","RX_META_LWT_MINIMUM","sortObject","trimDots","getPseudoSchemaForVersion","version","primaryKey","pseudoSchema","fillWithDefaultSettings","type","properties","maxLength","required","getSchemaByObjectPath","rxJsonSchema","path","usePath","replace","ret","get","fillPrimaryKey","primaryPath","jsonSchema","documentData","cloned","newPrimary","getComposedPrimaryKeyOfDocumentData","existingPrimary","args","schema","getPrimaryFieldOfPrimaryKey","key","compositePrimary","fields","map","field","value","join","separator","normalizeRxJsonSchema","normalizedSchema","indexes","Array","from","schemaObj","additionalProperties","hasOwnProperty","keyCompression","slice","encrypted","_rev","minLength","_attachments","_deleted","_meta","RX_META_SCHEMA","push","finalFields","getFinalFields","concat","filter","includes","elem","pos","arr","indexOf","index","arIndex","modifiedIndex","lwt","minimum","maximum","multipleOf","Object","keys","forEach"],"mappings":"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","sourcesContent":["import objectPath from 'object-path';\nimport { newRxError } from './rx-error';\nimport type {\n    CompositePrimaryKey,\n    JsonSchema,\n    PrimaryKey,\n    RxDocumentData,\n    RxJsonSchema,\n    StringKeys\n} from './types';\nimport { clone, flatClone, isMaybeReadonlyArray, RX_META_LWT_MINIMUM, sortObject, trimDots } from './util';\n\n/**\n * Helper function to create a valid RxJsonSchema\n * with a given version.\n */\nexport function getPseudoSchemaForVersion<T = any>(\n    version: number,\n    primaryKey: StringKeys<T>\n): RxJsonSchema<RxDocumentData<T>> {\n    const pseudoSchema: RxJsonSchema<RxDocumentData<T>> = fillWithDefaultSettings({\n        version,\n        type: 'object',\n        primaryKey: primaryKey as any,\n        properties: {\n            [primaryKey]: {\n                type: 'string',\n                maxLength: 100\n            }\n        } as any,\n        required: [primaryKey]\n    });\n    return pseudoSchema;\n}\n\n/**\n * Returns the sub-schema for a given path\n */\nexport function getSchemaByObjectPath<T = any>(\n    rxJsonSchema: RxJsonSchema<T>,\n    path: keyof T | string\n): JsonSchema {\n    let usePath: string = path as string;\n    usePath = usePath.replace(/\\./g, '.properties.');\n    usePath = 'properties.' + usePath;\n    usePath = trimDots(usePath);\n\n    const ret = objectPath.get(rxJsonSchema, usePath);\n    return ret;\n}\n\nexport function fillPrimaryKey<T>(\n    primaryPath: keyof T,\n    jsonSchema: RxJsonSchema<T>,\n    documentData: RxDocumentData<T>\n): RxDocumentData<T> {\n    const cloned = flatClone(documentData);\n    const newPrimary = getComposedPrimaryKeyOfDocumentData<T>(\n        jsonSchema,\n        documentData\n    );\n    const existingPrimary: string | undefined = documentData[primaryPath] as any;\n    if (\n        existingPrimary &&\n        existingPrimary !== newPrimary\n    ) {\n        throw newRxError(\n            'DOC19',\n            {\n                args: {\n                    documentData,\n                    existingPrimary,\n                    newPrimary,\n                },\n                schema: jsonSchema\n            });\n    }\n\n    (cloned as any)[primaryPath] = newPrimary;\n    return cloned;\n}\n\nexport function getPrimaryFieldOfPrimaryKey<RxDocType>(\n    primaryKey: PrimaryKey<RxDocType>\n): keyof RxDocType {\n    if (typeof primaryKey === 'string') {\n        return primaryKey as any;\n    } else {\n        return (primaryKey as CompositePrimaryKey<RxDocType>).key;\n    }\n}\n\n/**\n * Returns the composed primaryKey of a document by its data.\n */\nexport function getComposedPrimaryKeyOfDocumentData<RxDocType>(\n    jsonSchema: RxJsonSchema<RxDocType> | RxJsonSchema<RxDocumentData<RxDocType>>,\n    documentData: Partial<RxDocType>\n): string {\n    if (typeof jsonSchema.primaryKey === 'string') {\n        return (documentData as any)[jsonSchema.primaryKey];\n    }\n\n    const compositePrimary: CompositePrimaryKey<RxDocType> = jsonSchema.primaryKey as any;\n    return compositePrimary.fields.map(field => {\n        const value = objectPath.get(documentData as any, field as string);\n        if (typeof value === 'undefined') {\n            throw newRxError('DOC18', { args: { field, documentData } });\n        }\n        return value;\n    }).join(compositePrimary.separator);\n}\n\n\n/**\n * Normalize the RxJsonSchema.\n * We need this to ensure everything is set up properly\n * and we have the same hash on schemas that represent the same value but\n * have different json.\n * \n * - Orders the schemas attributes by alphabetical order\n * - Adds the primaryKey to all indexes that do not contain the primaryKey\n * - We need this for determinstic sort order on all queries, which is required for event-reduce to work.\n *\n * @return RxJsonSchema - ordered and filled\n */\nexport function normalizeRxJsonSchema<T>(jsonSchema: RxJsonSchema<T>): RxJsonSchema<T> {\n    // TODO do we need the deep clone() here?\n    const normalizedSchema: RxJsonSchema<T> = sortObject(clone(jsonSchema));\n\n    // indexes must NOT be sorted because sort order is important here.\n    if (jsonSchema.indexes) {\n        normalizedSchema.indexes = Array.from(jsonSchema.indexes);\n    }\n\n    // primaryKey.fields must NOT be sorted because sort order is important here.\n    if (\n        typeof normalizedSchema.primaryKey === 'object' &&\n        typeof jsonSchema.primaryKey === 'object'\n    ) {\n        normalizedSchema.primaryKey.fields = jsonSchema.primaryKey.fields;\n    }\n\n\n\n    return normalizedSchema;\n}\n\n/**\n * fills the schema-json with default-settings\n * @return cloned schemaObj\n */\nexport function fillWithDefaultSettings<T = any>(\n    schemaObj: RxJsonSchema<T>\n): RxJsonSchema<RxDocumentData<T>> {\n    schemaObj = flatClone(schemaObj);\n    const primaryPath: string = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey) as string;\n    schemaObj.properties = flatClone(schemaObj.properties);\n\n    // additionalProperties is always false\n    schemaObj.additionalProperties = false;\n\n    // fill with key-compression-state ()\n    if (!schemaObj.hasOwnProperty('keyCompression')) {\n        schemaObj.keyCompression = false;\n    }\n\n    // indexes must be array\n    schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];\n\n    // required must be array\n    schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n\n    // encrypted must be array\n    schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];\n\n    /**\n     * TODO we should not need to add the internal fields to the schema.\n     * Better remove the fields before validation.\n     */\n    // add _rev\n    (schemaObj.properties as any)._rev = {\n        type: 'string',\n        minLength: 1\n    };\n\n    // add attachments\n    (schemaObj.properties as any)._attachments = {\n        type: 'object'\n    };\n\n    // add deleted flag\n    (schemaObj.properties as any)._deleted = {\n        type: 'boolean'\n    };\n\n    // add meta property\n    (schemaObj.properties as any)._meta = RX_META_SCHEMA;\n\n    /**\n     * meta fields are all required\n     */\n    schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n    (schemaObj.required as string[]).push('_deleted');\n    (schemaObj.required as string[]).push('_rev');\n    (schemaObj.required as string[]).push('_meta');\n    (schemaObj.required as string[]).push('_attachments');\n\n    // final fields are always required\n    const finalFields = getFinalFields(schemaObj);\n    schemaObj.required = schemaObj.required\n        .concat(finalFields as any)\n        .filter((field: string) => !field.includes('.'))\n        .filter((elem: any, pos: any, arr: any) => arr.indexOf(elem) === pos); // unique;\n\n    // version is 0 by default\n    schemaObj.version = schemaObj.version || 0;\n\n    /**\n     * Append primary key to indexes that do not contain the primaryKey.\n     * All indexes must have the primaryKey to ensure a deterministic sort order.\n     */\n    if (schemaObj.indexes) {\n        schemaObj.indexes = schemaObj.indexes.map(index => {\n            const arIndex = isMaybeReadonlyArray(index) ? index.slice(0) : [index];\n            if (!arIndex.includes(primaryPath)) {\n                const modifiedIndex = arIndex.slice(0);\n                modifiedIndex.push(primaryPath);\n                return modifiedIndex;\n            }\n            return arIndex;\n        });\n    }\n\n    return schemaObj as any;\n}\n\n\nexport const RX_META_SCHEMA: JsonSchema = {\n    type: 'object',\n    properties: {\n        /**\n         * The last-write time.\n         * Unix time in milliseconds.\n         */\n        lwt: {\n            type: 'number',\n            /**\n             * We use 1 as minimum so that the value is never falsy.\n             */\n            minimum: RX_META_LWT_MINIMUM,\n            maximum: 1000000000000000,\n            multipleOf: 1\n        }\n    },\n    /**\n     * Additional properties are allowed\n     * and can be used by plugins to set various flags.\n     */\n    additionalProperties: true as any,\n    required: [\n        'lwt'\n    ]\n}\n\n\n/**\n * returns the final-fields of the schema\n * @return field-names of the final-fields\n */\nexport function getFinalFields<T = any>(\n    jsonSchema: RxJsonSchema<T>\n): string[] {\n    const ret = Object.keys(jsonSchema.properties)\n        .filter(key => (jsonSchema as any).properties[key].final);\n\n    // primary is also final\n    const primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n    ret.push(primaryPath as string);\n\n    // fields of composite primary are final\n    if (typeof jsonSchema.primaryKey !== 'string') {\n        (jsonSchema.primaryKey as CompositePrimaryKey<T>).fields\n            .forEach(field => ret.push(field as string));\n    }\n\n    return ret;\n}\n"],"file":"rx-schema-helper.js"}