{"version":3,"sources":["../../../src/plugins/encryption.ts"],"names":["body","recover","result","e","then","storePasswordHashIntoDatabase","rxDatabase","pwHash","pwHashDoc","data","hash","destroy","passwordHash","password","existingPasswordHash","PROMISE_RESOLVE_FALSE","pwHashDocumentKey","pwHashDocumentId","INTERNAL_CONTEXT_ENCRYPTION","docData","id","key","context","_deleted","_attachments","_meta","lwt","_rev","internalStore","document","err","isError","status","documentInDb","MINIMUM_PASSWORD_LENGTH","encryptString","value","encrypted","AES","encrypt","toString","decryptString","cipherText","args","decrypted","decrypt","ret","cryptoEnc","cloneWithoutAttachments","attachments","RxDBEncryptionPlugin","name","rxdb","prototypes","overwritable","validatePassword","length","minPassLength","hooks","createRxDatabase","after","database","preWriteToStorageInstance","before","schema","doc","forEach","path","objectPath","get","stringValue","JSON","stringify","set","postReadFromInstance","decryptedParsed","parse","preWriteAttachment","dataString","attachmentData","postReadAttachment","plainData"],"mappings":"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","sourcesContent":["/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\n\nimport AES from 'crypto-js/aes';\nimport * as cryptoEnc from 'crypto-js/enc-utf8';\n\nimport {\n    newRxTypeError,\n    newRxError\n} from '../rx-error';\n\nimport objectPath from 'object-path';\nimport type {\n    RxPlugin,\n    RxDatabase,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxStorageBulkWriteError\n} from '../types';\nimport {\n    clone,\n    createRevision,\n    flatClone,\n    getDefaultRevision,\n    hash,\n    now,\n    PROMISE_RESOLVE_FALSE\n} from '../util';\nimport { writeSingle } from '../rx-storage-helper';\nimport {\n    getPrimaryKeyOfInternalDocument,\n    InternalStoreDocType,\n    INTERNAL_CONTEXT_ENCRYPTION\n} from '../rx-database-internal-store';\n\nexport const MINIMUM_PASSWORD_LENGTH: 8 = 8;\n\n\nexport function encryptString(value: string, password: string): string {\n    const encrypted = AES.encrypt(value, password);\n    return encrypted.toString();\n}\n\nexport function decryptString(cipherText: string, password: any): string {\n    /**\n     * Trying to decrypt non-strings\n     * will cause no errors and will be hard to debug.\n     * So instead we do this check here.\n     */\n    if (typeof cipherText !== 'string') {\n        throw newRxError('SNH', {\n            args: {\n                cipherText\n            }\n        });\n    }\n\n    const decrypted = AES.decrypt(cipherText, password);\n    const ret = decrypted.toString(cryptoEnc);\n    return ret;\n}\n\n\nexport type InternalStorePasswordDocType = InternalStoreDocType<{\n    hash: string;\n}>;\n\n/**\n * validates and inserts the password hash into the internal collection\n * to ensure there is/was no other instance with a different password\n * which would cause strange side effects when both instances save into the same db\n */\nexport async function storePasswordHashIntoDatabase(\n    rxDatabase: RxDatabase\n): Promise<boolean> {\n    if (!rxDatabase.password) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n    const pwHash = hash(rxDatabase.password);\n    const pwHashDocumentKey = 'pwHash';\n    const pwHashDocumentId = getPrimaryKeyOfInternalDocument(\n        pwHashDocumentKey,\n        INTERNAL_CONTEXT_ENCRYPTION\n    );\n\n    const docData: RxDocumentWriteData<InternalStorePasswordDocType> = {\n        id: pwHashDocumentId,\n        key: pwHashDocumentKey,\n        context: INTERNAL_CONTEXT_ENCRYPTION,\n        data: {\n            hash: pwHash\n        },\n        _deleted: false,\n        _attachments: {},\n        _meta: {\n            lwt: now()\n        },\n        _rev: getDefaultRevision()\n    };\n    docData._rev = createRevision(docData);\n\n    let pwHashDoc;\n    try {\n        pwHashDoc = await writeSingle(\n            rxDatabase.internalStore,\n            {\n                document: docData\n            }\n        );\n    } catch (err) {\n        if (\n            (err as any).isError &&\n            (err as RxStorageBulkWriteError<InternalStorePasswordDocType>).status === 409\n        ) {\n            pwHashDoc = (err as RxStorageBulkWriteError<InternalStorePasswordDocType>).documentInDb;\n        } else {\n            throw err;\n        }\n    }\n\n    if (pwHash !== pwHashDoc.data.hash) {\n        // different hash was already set by other instance\n        await rxDatabase.destroy();\n        throw newRxError('DB1', {\n            passwordHash: hash(rxDatabase.password),\n            existingPasswordHash: pwHashDoc.data.hash\n        });\n    } else {\n        return true;\n    }\n}\n\n\nfunction cloneWithoutAttachments<T>(data: RxDocumentData<T>): RxDocumentData<T> {\n    const attachments = data._attachments;\n    data = flatClone(data);\n    delete (data as any)._attachments;\n    data = clone(data);\n    data._attachments = attachments;\n    return data;\n}\n\nexport const RxDBEncryptionPlugin: RxPlugin = {\n    name: 'encryption',\n    rxdb: true,\n    prototypes: {},\n    overwritable: {\n        validatePassword: function (password: any) {\n            if (password && typeof password !== 'string') {\n                throw newRxTypeError('EN1', {\n                    password\n                });\n            }\n            if (password && password.length < MINIMUM_PASSWORD_LENGTH) {\n                throw newRxError('EN2', {\n                    minPassLength: MINIMUM_PASSWORD_LENGTH,\n                    password\n                });\n            }\n        }\n    },\n    hooks: {\n        createRxDatabase: {\n            after: args => {\n                return storePasswordHashIntoDatabase(args.database);\n            }\n        },\n        preWriteToStorageInstance: {\n            before: (args) => {\n                const password = args.database.password;\n                const schema = args.schema\n                if (\n                    !password ||\n                    !schema.encrypted ||\n                    schema.encrypted.length === 0\n                ) {\n                    return;\n                }\n\n                const docData = cloneWithoutAttachments(args.doc);\n                schema.encrypted\n                    .forEach(path => {\n                        const value = objectPath.get(docData, path);\n                        if (typeof value === 'undefined') {\n                            return;\n                        }\n\n                        const stringValue = JSON.stringify(value);\n                        const encrypted = encryptString(stringValue, password);\n                        objectPath.set(docData, path, encrypted);\n                    });\n                args.doc = docData;\n            }\n        },\n        postReadFromInstance: {\n            after: (args) => {\n                const password = args.database.password;\n                const schema = args.schema\n                if (\n                    !password ||\n                    !schema.encrypted ||\n                    schema.encrypted.length === 0\n                ) {\n                    return;\n                }\n                const docData = cloneWithoutAttachments(args.doc);\n                schema.encrypted\n                    .forEach(path => {\n                        const value = objectPath.get(docData, path);\n                        if (typeof value === 'undefined') {\n                            return;\n                        }\n                        const decrypted = decryptString(value, password);\n                        const decryptedParsed = JSON.parse(decrypted);\n                        objectPath.set(docData, path, decryptedParsed);\n                    });\n                args.doc = docData;\n            }\n        },\n        preWriteAttachment: {\n            after: async (args) => {\n                const password = args.database.password;\n                const schema = args.schema\n                if (\n                    password &&\n                    schema.attachments &&\n                    schema.attachments.encrypted\n                ) {\n                    const dataString = args.attachmentData.data;\n                    const encrypted = encryptString(dataString, password);\n                    args.attachmentData.data = encrypted;\n                }\n            }\n        },\n        postReadAttachment: {\n            after: async (args) => {\n                const password = args.database.password;\n                const schema = args.schema\n                if (\n                    password &&\n                    schema.attachments &&\n                    schema.attachments.encrypted\n                ) {\n                    const dataString = args.plainData;\n                    const decrypted = decryptString(dataString, password);\n                    args.plainData = decrypted;\n                }\n            }\n        }\n    }\n};\n"],"file":"encryption.js"}