{"version":3,"sources":["../../../../src/plugins/pouchdb/custom-events-plugin.ts"],"names":["eventEmitDataToStorageEvents","pouchDBInstance","primaryPath","emitData","ret","writeOptions","custom","hasOwnProperty","new_edits","Promise","all","writeDocs","map","writeDoc","id","_id","_attachments","previousDoc","previousDocs","get","parsedRevPrevious","_rev","parsedRevNew","height","hash","_deleted","event","operation","doc","previous","args","changeEvent","changeEventToNormal","startTime","endTime","push","writeRowById","writeDocsById","Map","forEach","set","writeResult","resultRow","startsWith","POUCHDB_DESIGN_PREFIX","POUCHDB_LOCAL_PREFIX","rev","writeMap","error","writeRow","document","attachments","newDoc","Object","assign","addedToPouch","EVENT_EMITTER_BY_POUCH_INSTANCE","getCustomEventEmitterByPouch","pouch","key","name","adapter","join","emitter","subject","Subject","i","BULK_DOC_RUN_QUEUE","WeakMap","addCustomEventsPluginToPouch","oldBulkDocs","PouchDBCore","prototype","bulkDocs","newBulkDocs","body","options","callback","queue","PROMISE_RESOLVE_VOID","then","newBulkDocsInner","bind","usePouchResult","hasNonErrorWrite","docs","insertDocsById","Array","from","entries","previousRev","newRev","docInDb","previousDocsInDb","docInDbRev","status","useRevisions","start","_revisions","ids","slice","unshift","useNewRev","ok","deeperOptions","isDeeper","callReturn","callPromise","res","rej","call","err","result","row","eventsPromise","emitId","runId","events","eventBulk","next","isArray","undefined","length","bulkGet","revs","latest","viaBulkGet","mustRefetchBecauseDeleted","results","firstDoc","reason","allDocs","keys","include_docs","conflicts","deletedDocsViaAllDocs","idsWithRevs","rows","value","deletedDocsViaBulkGetWithRev","plugin","change","primary","storageChangeEvent","eventId","documentId"],"mappings":"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","sourcesContent":["/*\n * Instead of listening to pouch.changes,\n * we overwrite pouchdbs bulkDocs()\n * and create our own event stream, this will work more reliable\n * and has less strange behaviors.\n * Also we can better define what data we need for our events.\n * @link http://jsbin.com/pagebi/1/edit?js,output\n * @link https://github.com/pubkey/rxdb/blob/1f4115b69bdacbb853af9c637d70f5f184d4e474/src/rx-storage-pouchdb.ts#L273\n */\n\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    PouchBulkDocOptions,\n    PouchBulkDocResultRow,\n    PouchDBInstance,\n    PouchWriteError,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from '../../types';\nimport PouchDBCore from 'pouchdb-core';\nimport { Subject } from 'rxjs';\nimport {\n    flatClone,\n    getFromMapOrThrow,\n    now,\n    parseRevision,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../../util';\nimport { newRxError } from '../../rx-error';\nimport {\n    getEventKey,\n    pouchChangeRowToChangeEvent,\n    POUCHDB_DESIGN_PREFIX,\n    POUCHDB_LOCAL_PREFIX,\n    pouchDocumentDataToRxDocumentData,\n    writeAttachmentsToAttachments\n} from './pouchdb-helper';\nimport type { ChangeEvent } from 'event-reduce-js';\n\n// ensure only added once\nlet addedToPouch = false;\n\ndeclare type EmitData = {\n    emitId: number;\n    writeOptions: PouchBulkDocOptions;\n    writeDocs: any[];\n    writeResult: (PouchBulkDocResultRow | PouchWriteError)[];\n    // used on new_edits=false to check if the last revision has changed\n    previousDocs: Map<string, any>;\n    startTime: number;\n    endTime: number;\n};\n\n\ndeclare type Emitter<RxDocType> = {\n    subject: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>>;\n};\nexport const EVENT_EMITTER_BY_POUCH_INSTANCE: Map<string, Emitter<any>> = new Map();\n\nexport function getCustomEventEmitterByPouch<RxDocType>(\n    pouch: PouchDBInstance\n): Emitter<RxDocType> {\n    const key = [\n        pouch.name,\n        pouch.adapter\n    ].join('|');\n    let emitter = EVENT_EMITTER_BY_POUCH_INSTANCE.get(key);\n    if (!emitter) {\n        emitter = {\n            subject: new Subject()\n        };\n        EVENT_EMITTER_BY_POUCH_INSTANCE.set(key, emitter);\n    }\n    return emitter;\n}\n\n\n/**\n * Counter, used to debug stuff.\n */\nlet i = 0;\n\n\n/**\n * Because we cannot force pouchdb to await bulkDocs runs\n * inside of a transaction, like done with the other RxStorage implementations,\n * we have to ensure the calls to bulkDocs() do not run in parallel. \n * \n * TODO this is somehow a hack. Instead of doing that, inspect how\n * PouchDB runs bulkDocs internally and adapt that transaction handling.\n */\nconst BULK_DOC_RUN_QUEUE: WeakMap<PouchDBInstance, Promise<any>> = new WeakMap();\n\n/**\n * PouchDB is like a minefield,\n * where stuff randomly does not work dependend on some conditions.\n * So instead of doing plain writes,\n * we hack into the bulkDocs() function\n * and adjust the behavior accordingly.\n */\nexport function addCustomEventsPluginToPouch() {\n    if (addedToPouch) {\n        return;\n    }\n    addedToPouch = true;\n\n    const oldBulkDocs: any = PouchDBCore.prototype.bulkDocs;\n\n    /**\n     * Ensure we do not run bulkDocs() in parallel on the same PouchDB instance.\n     */\n    const newBulkDocs = async function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n        let queue = BULK_DOC_RUN_QUEUE.get(this);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue.then(async () => {\n            const ret = await newBulkDocsInner.bind(this)(\n                body,\n                options,\n                callback\n            );\n            return ret;\n        });\n        BULK_DOC_RUN_QUEUE.set(this, queue);\n        return queue;\n    };\n\n\n    const newBulkDocsInner = async function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n        const startTime = now();\n        const runId = i++;\n\n        // normalize input\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n\n        let docs: any[];\n        if (Array.isArray(body)) {\n            docs = body;\n        } else if (body === undefined) {\n            docs = [];\n        } else {\n            docs = body.docs;\n            if (body.hasOwnProperty('new_edits')) {\n                options.new_edits = body.new_edits;\n            }\n        }\n\n        // throw if no docs given, because RxDB should never make such a call.\n        if (docs.length === 0) {\n            throw newRxError('SNH', {\n                args: {\n                    body,\n                    options\n                }\n            });\n        }\n\n\n        /**\n         * If new_edits=false we have to first find the current state\n         * of the document and can later check if the state was changed\n         * because a new revision was written and we have to emit an event.\n         */\n        const previousDocsInDb: Map<string, RxDocumentData<any>> = options.custom ? options.custom.previousDocsInDb : new Map();\n        if (\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            const viaBulkGet = await this.bulkGet({\n                docs: docs.map(doc => ({ id: doc._id })),\n                revs: true,\n                latest: true\n            });\n\n            /**\n             * bulkGet() does not return deleted documents,\n             * so we must refetch them via allDocs() afterwards.\n             */\n            const mustRefetchBecauseDeleted: string[] = [];\n\n            viaBulkGet.results.forEach(resultRow => {\n                const firstDoc = resultRow.docs[0];\n                if (firstDoc.ok) {\n                    previousDocsInDb.set(firstDoc.ok._id, firstDoc.ok);\n                } else {\n                    if (firstDoc.error && firstDoc.error.reason === 'deleted') {\n                        mustRefetchBecauseDeleted.push(resultRow.id);\n                    }\n                }\n            });\n\n            if (mustRefetchBecauseDeleted.length > 0) {\n                const deletedDocsViaAllDocs = await this.allDocs({\n                    keys: mustRefetchBecauseDeleted,\n                    include_docs: true,\n                    conflicts: true,\n                });\n\n                const idsWithRevs: { id: string; rev: string; }[] = [];\n                deletedDocsViaAllDocs.rows.forEach(row => {\n                    idsWithRevs.push({\n                        id: row.id,\n                        rev: row.value.rev\n                    });\n                });\n\n                const deletedDocsViaBulkGetWithRev = await this.bulkGet({\n                    docs: idsWithRevs,\n                    revs: true,\n                    latest: true\n                });\n\n                deletedDocsViaBulkGetWithRev.results.forEach(resultRow => {\n                    const firstDoc = resultRow.docs[0];\n                    if (firstDoc.ok) {\n                        previousDocsInDb.set(firstDoc.ok._id, firstDoc.ok);\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                deletedDocsViaBulkGetWithRev,\n                                resultRow\n                            }\n                        });\n                    }\n                });\n\n            }\n        }\n\n        /**\n         * Custom handling if the call came from RxDB (options.custom is set).\n         */\n        const usePouchResult: (PouchBulkDocResultRow | PouchWriteError)[] = [];\n        let hasNonErrorWrite = false;\n        if (\n            options.custom &&\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            /**\n             * Reset the write docs array,\n             * because we only write non-conflicting documents.\n             */\n            docs = [];\n            const writeRowById: Map<string, BulkWriteRow<any>> = options.custom.writeRowById;\n            const insertDocsById: Map<string, any> = options.custom.insertDocsById;\n\n            Array.from(writeRowById.entries()).forEach(([id, writeRow]) => {\n                const previousRev = writeRow.previous ? writeRow.previous._rev : null;\n                const newRev = parseRevision(writeRow.document._rev);\n                const docInDb = previousDocsInDb.get(id);\n                const docInDbRev: string | null = docInDb ? docInDb._rev : null;\n\n                if (\n                    docInDbRev !== previousRev &&\n                    /**\n                     * If doc in db is deleted\n                     * and no previous docs was send,\n                     * We have a re-insert which must not cause a conflict.\n                     */\n                    !(\n                        docInDb &&\n                        docInDb._deleted &&\n                        !writeRow.previous\n                    )\n                ) {\n                    // we have a conflict\n                    usePouchResult.push({\n                        error: true,\n                        id,\n                        status: 409\n                    });\n                } else {\n                    const useRevisions = {\n                        start: docInDb ? docInDb._revisions.start + 1 : newRev.height,\n                        ids: docInDb ? docInDb._revisions.ids.slice(0) : []\n                    };\n                    useRevisions.ids.unshift(newRev.hash);\n                    const useNewRev = useRevisions.start + '-' + newRev.hash;\n\n                    hasNonErrorWrite = true;\n                    docs.push(\n                        Object.assign(\n                            {},\n                            insertDocsById.get(id),\n                            {\n                                _revisions: useRevisions,\n                                _rev: useNewRev\n                            }\n                        )\n                    );\n                    usePouchResult.push({\n                        ok: true,\n                        id,\n                        rev: writeRow.document._rev\n                    });\n                }\n            });\n\n            /**\n             * Optimization shortcut,\n             * if all document writes were conflict errors,\n             * we can skip directly.\n             */\n            if (!hasNonErrorWrite) {\n                return usePouchResult;\n            }\n        }\n\n        /**\n         * pouchdb calls this function again with transformed input.\n         * This would lead to duplicate events. So we marks the deeper calls via the options\n         * parameter and do not emit events if it is set.\n         */\n        const deeperOptions = flatClone(options);\n        deeperOptions.isDeeper = true;\n        let callReturn: any;\n        const callPromise = new Promise((res, rej) => {\n            callReturn = oldBulkDocs.call(\n                this, docs,\n                deeperOptions,\n                (err: any, result: (PouchBulkDocResultRow | PouchWriteError)[]) => {\n                    if (err) {\n                        callback ? callback(err) : rej(err);\n                    } else {\n                        return (async () => {\n\n                            result.forEach(row => {\n                                usePouchResult.push(row);\n                            });\n\n                            /**\n                             * For calls that came from RxDB,\n                             * we have to ensure that the events are emitted\n                             * before the actual call resolves.\n                             */\n                            let eventsPromise = PROMISE_RESOLVE_VOID;\n                            if (!options.isDeeper) {\n                                const endTime = now();\n                                const emitData = {\n                                    emitId: runId,\n                                    writeDocs: docs,\n                                    writeOptions: options,\n                                    writeResult: usePouchResult,\n                                    previousDocs: previousDocsInDb,\n                                    startTime,\n                                    endTime\n                                };\n                                eventsPromise = eventEmitDataToStorageEvents(\n                                    this,\n                                    '_id',\n                                    emitData\n                                ).then(events => {\n                                    const eventBulk: EventBulk<any> = {\n                                        id: randomCouchString(10),\n                                        events\n                                    };\n\n                                    const emitter = getCustomEventEmitterByPouch(this);\n                                    emitter.subject.next(eventBulk);\n                                });\n                            }\n\n                            if (callback) {\n                                callback(null, usePouchResult);\n                            } else {\n                                return eventsPromise.then(() => {\n                                    res(usePouchResult);\n                                    return usePouchResult;\n                                });\n                            }\n                        })();\n                    }\n                });\n        });\n\n        if (options.custom) {\n            return callPromise;\n        }\n        return callReturn;\n    };\n\n    PouchDBCore.plugin({\n        bulkDocs: newBulkDocs\n    } as any);\n\n}\n\nexport async function eventEmitDataToStorageEvents<RxDocType>(\n    pouchDBInstance: PouchDBInstance,\n    primaryPath: string,\n    emitData: EmitData\n): Promise<RxStorageChangeEvent<RxDocumentData<RxDocType>>[]> {\n    const ret: RxStorageChangeEvent<RxDocumentData<RxDocType>>[] = [];\n    if (\n        !emitData.writeOptions.custom &&\n        emitData.writeOptions.hasOwnProperty('new_edits') &&\n        emitData.writeOptions.new_edits === false\n    ) {\n        await Promise.all(\n            emitData.writeDocs.map(async (writeDoc) => {\n                const id = writeDoc._id;\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n                let previousDoc = emitData.previousDocs.get(id);\n                if (previousDoc) {\n                    previousDoc = pouchDocumentDataToRxDocumentData(\n                        primaryPath,\n                        previousDoc\n                    );\n                }\n                if (previousDoc) {\n                    const parsedRevPrevious = parseRevision(previousDoc._rev);\n                    const parsedRevNew = parseRevision(writeDoc._rev);\n                    if (\n                        (\n                            parsedRevPrevious.height > parsedRevNew.height ||\n                            /**\n                             * If the revision height is equal,\n                             * we determine the higher hash as winner.\n                             */\n                            (\n                                parsedRevPrevious.height === parsedRevNew.height &&\n                                parsedRevPrevious.hash > parsedRevNew.hash\n                            )\n                        )\n                    ) {\n                        /**\n                         * The newly added document was not the latest revision\n                         * so we drop the write.\n                         * With plain PouchDB it makes sense to store conflicting branches of the document\n                         * but RxDB assumes that the conflict is resolved directly.\n                         */\n                        return;\n                    }\n                }\n\n                if (!previousDoc && writeDoc._deleted) {\n                    // deleted document was added as revision\n                    return;\n                }\n\n                if (previousDoc && previousDoc._deleted && writeDoc._deleted) {\n                    // delete document was deleted again\n                    return;\n                }\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if ((!previousDoc || previousDoc._deleted) && !writeDoc._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: writeDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeDoc._deleted && previousDoc && !previousDoc._deleted) {\n                    // was delete\n                    previousDoc._rev = writeDoc._rev;\n                    event = {\n                        operation: 'DELETE',\n                        doc: null,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else if (\n                    previousDoc\n                ) {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: writeDoc,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else {\n                    throw newRxError('SNH', { args: { writeDoc } });\n                }\n\n                const changeEvent = changeEventToNormal(\n                    pouchDBInstance,\n                    primaryPath,\n                    event,\n                    emitData.startTime,\n                    emitData.endTime\n                );\n\n                ret.push(changeEvent);\n            })\n        );\n    }\n    /**\n     * There is no write map given for internal pouchdb document writes\n     * like it is done with replication.\n     */\n    else if (\n        !emitData.writeOptions.custom ||\n        (emitData.writeOptions.custom && !emitData.writeOptions.custom.writeRowById)\n    ) {\n        const writeDocsById: Map<string, any> = new Map();\n        emitData.writeDocs.forEach(writeDoc => writeDocsById.set(writeDoc._id, writeDoc));\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                const id = resultRow.id;\n                if (\n                    id.startsWith(POUCHDB_DESIGN_PREFIX) ||\n                    id.startsWith(POUCHDB_LOCAL_PREFIX)\n                ) {\n                    return;\n                }\n                let writeDoc = getFromMapOrThrow(writeDocsById, resultRow.id);\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n                writeDoc = flatClone(writeDoc);\n                writeDoc._rev = (resultRow as any).rev;\n                const event = pouchChangeRowToChangeEvent<RxDocType>(\n                    primaryPath as any,\n                    writeDoc\n                );\n                const changeEvent = changeEventToNormal(pouchDBInstance, primaryPath, event);\n                ret.push(changeEvent);\n            })\n        );\n    } else {\n        const writeMap: Map<string, BulkWriteRow<RxDocType>> = emitData.writeOptions.custom.writeRowById;\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                if ((resultRow as PouchWriteError).error) {\n                    return;\n                }\n                const id = resultRow.id;\n                const writeRow = getFromMapOrThrow(writeMap, id);\n                const attachments = await writeAttachmentsToAttachments(writeRow.document._attachments);\n                const newDoc: RxDocumentData<RxDocType> = Object.assign(\n                    {},\n                    writeRow.document,\n                    {\n                        _attachments: attachments,\n                        _rev: (resultRow as PouchBulkDocResultRow).rev\n                    }\n                );\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if (!writeRow.previous || writeRow.previous._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: newDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeRow.document._deleted) {\n                    // was delete\n\n                    // we need to add the new revision to the previous doc\n                    // so that the eventkey is calculated correctly.\n                    // Is this a hack? idk.\n                    const attachments = await writeAttachmentsToAttachments(writeRow.previous._attachments);\n                    const previousDoc = Object.assign(\n                        {},\n                        writeRow.previous,\n                        {\n                            _attachments: attachments\n                        }\n                    );\n\n                    event = {\n                        operation: 'DELETE',\n                        doc: null,\n                        id: resultRow.id,\n                        previous: previousDoc\n                    };\n                } else {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: newDoc,\n                        id: resultRow.id,\n                        previous: writeRow.previous\n                    };\n                }\n\n                if (\n                    writeRow.document._deleted &&\n                    (\n                        !writeRow.previous ||\n                        writeRow.previous._deleted\n                    )\n                ) {\n                    /**\n                     * A deleted document was newly added to the storage engine,\n                     * do not emit an event.\n                     */\n                } else {\n                    const changeEvent = changeEventToNormal(\n                        pouchDBInstance,\n                        emitData.writeOptions.custom.primaryPath,\n                        event,\n                        emitData.startTime,\n                        emitData.endTime\n                    );\n                    ret.push(changeEvent);\n                }\n            })\n        );\n    }\n\n    return ret;\n}\n\nexport function changeEventToNormal<RxDocType>(\n    pouchDBInstance: PouchDBInstance,\n    primaryPath: string,\n    change: ChangeEvent<RxDocumentData<RxDocType>>,\n    startTime?: number,\n    endTime?: number\n): RxStorageChangeEvent<RxDocumentData<RxDocType>> {\n    const doc: RxDocumentData<RxDocType> = change.operation === 'DELETE' ? change.previous as any : change.doc as any;\n    const primary: string = (doc as any)[primaryPath];\n    const storageChangeEvent: RxStorageChangeEvent<RxDocumentData<RxDocType>> = {\n        eventId: getEventKey(pouchDBInstance, primary, change),\n        documentId: primary,\n        change,\n        startTime,\n        endTime\n    };\n    return storageChangeEvent;\n}\n"],"file":"custom-events-plugin.js"}